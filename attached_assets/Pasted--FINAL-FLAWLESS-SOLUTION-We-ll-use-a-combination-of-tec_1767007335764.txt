‚úÖ FINAL, FLAWLESS SOLUTION
We‚Äôll use a combination of techniques:

Delay scroll to let React finish rendering
Prevent browser auto-scroll by avoiding focus traps
Use requestAnimationFrame + setTimeout for maximum reliability
Scroll to a stable anchor (not just any div)
üîß STEP 1: Add a Dedicated Scroll Anchor
Inside your quiz card, add a tiny, invisible anchor at the very top:

{/* Add this as the FIRST element inside #quiz-card */}
<div id="quiz-top-anchor" style={{ 
  position: 'absolute', 
  top: '0', 
  left: '0', 
  width: '1px', 
  height: '1px', 
  opacity: '0' 
}}></div>
‚úÖ This gives us a precise, unchanging target to scroll to ‚Äî unaffected by content height changes.

üîß STEP 2: Replace All Scroll Logic with One Reliable Function
Add this utility function inside your component (or in a utils file):

// Scroll to top of quiz ‚Äî rock solid
const scrollToQuizTop = () => {
  // Use requestAnimationFrame to wait for layout
  requestAnimationFrame(() => {
    // Small delay to ensure DOM is stable
    setTimeout(() => {
      const anchor = document.getElementById('quiz-top-anchor');
      if (anchor) {
        anchor.scrollIntoView({ 
          behavior: 'instant', // or 'smooth' if you prefer
          block: 'start',
          inline: 'nearest'
        });
      }
    }, 50); // 50ms is enough ‚Äî minimal delay
  });
};
üí° Why behavior: 'instant'?

Prevents scroll animation from being interrupted
Feels ‚Äúsnappy‚Äù and intentional (like native apps)
You can change to 'smooth' if you prefer
üîß STEP 3: Use This Function in 3 Key Places
A. On Component Mount
useEffect(() => {
  scrollToQuizTop();
}, []);
B. After Difficulty Selection
useEffect(() => {
  if (difficulty) {
    // Slight extra delay after UI change
    setTimeout(scrollToQuizTop, 100);
  }
}, [difficulty]);
C. After Answer Selection
const handleAnswerSelect = (answerIndex: number) => {
  if (selectedAnswer !== null) return;
  
  setSelectedAnswer(answerIndex);
  setShowExplanation(true);

  if (answerIndex === question.correctAnswer) {
    setScore(score + 1);
    setStreak(streak + 1);
    setMaxStreak(Math.max(maxStreak, streak + 1));
  } else {
    setStreak(0);
  }

  // ‚úÖ FLAWLESS SCROLL ‚Äî no conflict
  setTimeout(scrollToQuizTop, 100);
};
‚úÖ 100ms delay ensures:

Feedback is rendered
Button appears
Browser stops auto-scrolling
Then you take control
üîß STEP 4: Prevent Button Auto-Focus (Critical)
Ensure your ‚ÄúNext Question‚Äù button does NOT receive focus automatically:

<Button 
  onClick={handleNextQuestion}
  // üëá ADD THIS ‚Äî prevents browser auto-scroll
  tabIndex={-1}
  className="bg-newari-red hover:bg-red-700 text-white min-h-[48px] px-8"
>
  {currentQuestion < filteredQuestions.length - 1 ? "Next Question" : "Finish Quiz"}
</Button>
üîç tabIndex={-1} removes it from tab order ‚Üí no accidental focus ‚Üí no auto-scroll.

If you need keyboard accessibility later, you can refocus after scroll ‚Äî but for now, this eliminates the conflict.

‚úÖ FULL UPDATED CulturalQuiz.tsx (Key Sections Only)
Here‚Äôs the minimal, surgical update ‚Äî you only need to change a few parts:

1. Add anchor + scroll function inside component:
export default function CulturalQuiz() {
  // ... all your state ...

  // ‚úÖ FLAWLESS SCROLL FUNCTION
  const scrollToQuizTop = () => {
    requestAnimationFrame(() => {
      setTimeout(() => {
        const anchor = document.getElementById('quiz-top-anchor');
        if (anchor) {
          anchor.scrollIntoView({ behavior: 'instant', block: 'start' });
        }
      }, 50);
    });
  };

  // Scroll on mount
  useEffect(() => {
    scrollToQuizTop();
  }, []);

  // Scroll after difficulty
  useEffect(() => {
    if (difficulty) {
      setTimeout(scrollToQuizTop, 100);
    }
  }, [difficulty]);

  // Answer handler
  const handleAnswerSelect = (answerIndex: number) => {
    if (selectedAnswer !== null) return;
    setSelectedAnswer(answerIndex);
    setShowExplanation(true);
    if (answerIndex === question.correctAnswer) {
      setScore(score + 1);
      setStreak(streak + 1);
      setMaxStreak(Math.max(maxStreak, streak + 1));
    } else {
      setStreak(0);
    }
    setTimeout(scrollToQuizTop, 100); // ‚úÖ
  };

  // ... rest of component ...
2. Add anchor as first element in quiz card:
return (
  <div id="quiz-card" style={{ ... }}>
    {/* ‚úÖ SCROLL ANCHOR ‚Äî MUST BE FIRST */}
    <div id="quiz-top-anchor" style={{ position: 'absolute', top: 0, left: 0, width: '1px', height: '1px', opacity: 0 }}></div>

    <div className="">
      {/* ... rest of content ... */}
    </div>
  </div>
);
3. Update ‚ÄúNext Question‚Äù button:
<Button 
  onClick={handleNextQuestion}
  tabIndex={-1} // ‚úÖ Prevents auto-focus scroll
  className="bg-newari-red hover:bg-red-700 text-white min-h-[48px] px-8"
>
  {currentQuestion < filteredQuestions.length - 1 ? "Next Question" : "Finish Quiz"}
</Button>
‚úÖ WHY THIS WORKS FLAWLESSLY
Technique	Purpose
#quiz-top-anchor	Stable, unchanging scroll target
requestAnimationFrame	Waits for layout engine
setTimeout(50‚Äì100ms)	Lets React + browser finish
behavior: 'instant'	No animation to interrupt
tabIndex={-1}	Prevents browser auto-scroll
No flicker. No jump. No conflict. Just clean, reliable UX.